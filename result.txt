----> BUILDING TASKS
make: Entering directory '/home/unix/Documents/c-unix/task1'
cc -o task1 main.c
make: Leaving directory '/home/unix/Documents/c-unix/task1'
make: Entering directory '/home/unix/Documents/c-unix/task2'
cc -o task2 main.c
make: Leaving directory '/home/unix/Documents/c-unix/task2'
make: Entering directory '/home/unix/Documents/c-unix/task3'
cc -o myinit main.c
make: Leaving directory '/home/unix/Documents/c-unix/task3'
====>-----------------------------------------------------------------------
----> TASK1 TEST
----> EXPECTED RESULT
fileA, fileB, fileC and fileD all contain the same data, so OS will report the same logical size for all of thme. But since fileB, fileC and fileD are sparse files, and fileA is not, by looking at the amount of allocated blocks on disk via 'stat' and multiplying by block size we can see that fileB, fileC and fileD take a lot less disk space. fileD takes more disk space due to an unconventional processing block size. We can also see, that gzip compresses data equally for sparse and non-sparse files.
----> TEST RESULT
Creating fileA
Creating a file, size: 4194305 bytes
Creating fileB
Copied 4194307 bytes
Creating fileA.gz
Creating fileB.gz
Unpacking fileB.gz | Packing fileC
Copied 4194307 bytes
Creating fileD with block size 100
Copied 4194307 bytes
==============================================
fileA:
  Logical size: 4194307 bytes
  8200 x 512 byte blocks -> 4198400 bytes of disk space used
fileB:
  Logical size: 4194307 bytes
  24 x 512 byte blocks -> 12288 bytes of disk space used
fileA.gz:
  Logical size: 4116 bytes
  16 x 512 byte blocks -> 8192 bytes of disk space used
fileB.gz:
  Logical size: 4116 bytes
  16 x 512 byte blocks -> 8192 bytes of disk space used
fileC:
  Logical size: 4194307 bytes
  24 x 512 byte blocks -> 12288 bytes of disk space used
fileD:
  Logical size: 4194307 bytes
  32 x 512 byte blocks -> 16384 bytes of disk space used
====>-----------------------------------------------------------------------
----> TASK2 TEST
----> EXPECTED RESULT
First test should fail after we delete the lock file in between capture and release. Next, 10 processes should all take turns (randomly) locking the file for 1 second each, and end up with approximately the same amount of locks for each process.
----> TEST RESULT
Testing lock file removal...
PID: 3977
runme.sh: Removing lock file!
Error opening lock file: No such file or directory
[0]	Unexpected termination!
[0]	Task 2
[0]	Waiting 1 sec to release the lock...
Not killing the process: it crases as supposed to
    PID TTY          TIME CMD
Waiting 5 seconds before continuing to the next test...
Started process #1 with PID 3986
Started process #2 with PID 3987
Started process #3 with PID 3988
Started process #4 with PID 3989
Started process #5 with PID 3990
Started process #6 with PID 3991
Started process #7 with PID 3992
Started process #8 with PID 3993
Started process #9 with PID 3994
Started process #10 with PID 3995
Killing #1 with PID 3986
Killing #2 with PID 3987
Killing #3 with PID 3988
Killing #4 with PID 3989
Killing #5 with PID 3990
Killing #6 with PID 3991
Killing #7 with PID 3992
Killing #8 with PID 3993
Killing #9 with PID 3994
Killing #10 with PID 3995
[3]	Task 2
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Waiting 1 sec to release the lock...
[3]	Termination by SIGINT
[4]	Task 2
[4]	Waiting 1 sec to release the lock...
[4]	Waiting 1 sec to release the lock...
[4]	Waiting 1 sec to release the lock...
[4]	Termination by SIGINT
[1]	Task 2
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Waiting 1 sec to release the lock...
[1]	Termination by SIGINT
[6]	Task 2
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Waiting 1 sec to release the lock...
[6]	Termination by SIGINT
[8]	Task 2
[8]	Waiting 1 sec to release the lock...
[8]	Waiting 1 sec to release the lock...
[8]	Waiting 1 sec to release the lock...
[8]	Waiting 1 sec to release the lock...
[8]	Waiting 1 sec to release the lock...
[8]	Termination by SIGINT
[10]	Task 2
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Waiting 1 sec to release the lock...
[10]	Termination by SIGINT
[7]	Task 2
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Waiting 1 sec to release the lock...
[7]	Termination by SIGINT
[9]	Task 2
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Waiting 1 sec to release the lock...
[9]	Termination by SIGINT
[5]	Task 2
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Waiting 1 sec to release the lock...
[5]	Termination by SIGINT
[2]	Task 2
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Waiting 1 sec to release the lock...
[2]	Termination by SIGINT
=================================================================
LOCK STATISTICS
Task number 3 (PID 3988) had 11 successful locks
Task number 4 (PID 3989) had 3 successful locks
Task number 1 (PID 3986) had 19 successful locks
Task number 6 (PID 3991) had 10 successful locks
Task number 8 (PID 3993) had 5 successful locks
Task number 10 (PID 3995) had 20 successful locks
Task number 7 (PID 3992) had 14 successful locks
Task number 9 (PID 3994) had 11 successful locks
Task number 5 (PID 3990) had 11 successful locks
Task number 2 (PID 3987) had 16 successful locks
====>-----------------------------------------------------------------------
----> TASK3 TEST
----> EXPECTED RESULT
Program should daemonize and run 3 child processes (from config generated by runme.sh). Then, after one of the processes is killed, it should restart it. Then, after config is overriten by runme.sh and SIGHUP is sent, the program should kill all of its child processes and start anew.
----> TEST RESULT
rm: cannot remove 'counter-output': No such file or directory
rm: cannot remove 'ticker-output': No such file or directory
myinit PID: 4038
Child processes: 3
Waiting 5 seconds...
Killing the second child (PID 4045)
Killed!
After 1 sec. Child processes: 3
OLD CONFIG CONTENTS:
-FILE START-----------------------------------------------------------
/home/unix/Documents/c-unix/task3/proc1.sh /dev/null /dev/null
/home/unix/Documents/c-unix/task3/counter.sh /dev/null /home/unix/Documents/c-unix/task3/counter-output
/home/unix/Documents/c-unix/task3/ticker.sh tick_message /home/unix/Documents/c-unix/task3/ticker-input /home/unix/Documents/c-unix/task3/ticker-output
-FILE END-------------------------------------------------------------
NEW CONFIG CONTENTS:
-FILE START-----------------------------------------------------------
/home/unix/Documents/c-unix/task3/proc1.sh /dev/null /dev/null
-FILE END-------------------------------------------------------------
Replaced config. Child processes: 1
Killed myinit
LOG FILE CONTENTS:
--------------------------------------------------------------
myinit daemonized and ready to run programs!
Config file /home/unix/Documents/c-unix/task3/runme.conf...
Config open, beginning read...
Found 3 required child process(es)
#0: /home/unix/Documents/c-unix/task3/proc1.sh < /dev/null > /dev/null
#1: /home/unix/Documents/c-unix/task3/counter.sh < /dev/null > /home/unix/Documents/c-unix/task3/counter-output
#2: /home/unix/Documents/c-unix/task3/ticker.sh tick_message < /home/unix/Documents/c-unix/task3/ticker-input > /home/unix/Documents/c-unix/task3/ticker-output
Config read, ready to serve processes!
Forking child process #0
Launched child process 0 with PID 4044
Forking child process #1
Preparing child process 0: /home/unix/Documents/c-unix/task3/proc1.sh < /dev/null > /dev/null
Launched child process 1 with PID 4045
Forking child process #2
Preparing child process 1: /home/unix/Documents/c-unix/task3/counter.sh < /dev/null > /home/unix/Documents/c-unix/task3/counter-output
Launched child process 2 with PID 4046
Preparing child process 2: /home/unix/Documents/c-unix/task3/ticker.sh tick_message < /home/unix/Documents/c-unix/task3/ticker-input > /home/unix/Documents/c-unix/task3/ticker-output
Child process 1 (PID 4045) ended.
Restarting...
Forking child process #1
Launched child process 1 with PID 4068
Preparing child process 1: /home/unix/Documents/c-unix/task3/counter.sh < /dev/null > /home/unix/Documents/c-unix/task3/counter-output
Restarting with signal 1
Killing child 0 (PID 4044)...
Killing child 1 (PID 4068)...
Killing child 2 (PID 4046)...
Config file /home/unix/Documents/c-unix/task3/runme.conf...
Config open, beginning read...
Found 1 required child process(es)
#0: /home/unix/Documents/c-unix/task3/proc1.sh < /dev/null > /dev/null
Config read, ready to serve processes!
Forking child process #0
Launched child process 0 with PID 4079
Preparing child process 0: /home/unix/Documents/c-unix/task3/proc1.sh < /dev/null > /dev/null
Restarting with signal 2
Killing child 0 (PID 4079)...
Goodbye!
Failed to close the stdin file (it might've not been open in the main process, so it's ok to see this message once): Bad file descriptor
